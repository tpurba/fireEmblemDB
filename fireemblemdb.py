# -*- coding: utf-8 -*-
"""FireEmblemDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q9gRtxBwJ1a4rGc8lQzwoEl95KtUC-U4
"""

import sqlite3


# Create or connect to a database file
fireEmblemConn = sqlite3.connect('FireEmblem.db')

fireEmblemCursor = fireEmblemConn.cursor()

with open('fullSetup.sql') as sql_setup_file:
    sql_setup_script = sql_setup_file.read()

fireEmblemCursor.executescript(sql_setup_script)

''' with open('setup2.sql', 'r') as sql_file:
    sql_script = sql_file.read()

fireEmblemCursor.executescript(sql_script) '''

with open('setupData.sql', 'r') as sql_data_file:
    sql_script = sql_data_file.read()

fireEmblemCursor.executescript(sql_script)

fireEmblemConn.commit()

!pip install openai

from openai import OpenAI

openAiClient = OpenAI(
    api_key = "hidden", 
    organization = "hidden"
)

commonSqlOnlyRequest = " Give me a sqlite select statement that answers the question. Only respond with sqlite syntax. If there is an error do not expalin it!"
strategies = {
    "zero_shot": sql_setup_script + commonSqlOnlyRequest,
    "single_domain_double_shot": (sql_setup_script +
                   " Who are the male characters in Fire Emblem? " +
                   " \nSELECT character_id, name\nFROM Character \nWHERE gender = M;\n " +
                   commonSqlOnlyRequest)
}

questions = [
    "Which two characters have the highest support?",
    "How many spell uses does Robin have in total?",
    "What skill does Chrom have?",
    "What tier is Robin's class?",
    "Who has the highest health growth rate?",
    "Who has mastered their class?"
    # "I need insert sql into my tables can you provide good unique data?"
]

def runSql(query):
    result = fireEmblemCursor.execute(query).fetchall()
    return result

def sanitizeForJustSql(value):
    gptStartSqlMarker = "```sql"
    gptEndSqlMarker = "```"
    if gptStartSqlMarker in value:
        value = value.split(gptStartSqlMarker)[1]
    if gptEndSqlMarker in value:
        value = value.split(gptEndSqlMarker)[0]

    return value

def getChatGptResponse(content):
    stream = openAiClient.chat.completions.create(
        model="gpt-3.5-turbo-0125",
        messages=[{"role": "user", "content": content}],
        stream=True,
    )

    responseList = []
    for chunk in stream:
        if chunk.choices[0].delta.content is not None:
            responseList.append(chunk.choices[0].delta.content)

    result = "".join(responseList)
    return result

import json
from time import time

for strategy in strategies:
    responses = {"strategy": strategy, "prompt_prefix": strategies[strategy]}
    questionResults = []
    for question in questions:
        print(question)
        error = "None"
        try:
            sqlSyntaxResponse = getChatGptResponse(strategies[strategy] + " " + question)
            sqlSyntaxResponse = sanitizeForJustSql(sqlSyntaxResponse)
            print(sqlSyntaxResponse)
            queryRawResponse = str(runSql(sqlSyntaxResponse))
            print(queryRawResponse)
            friendlyResultsPrompt = "I asked a question \"" + question +"\" and the response was \""+queryRawResponse+"\" Please, just give a concise response in a more friendly way? Please do not give any other suggests or chatter."
            friendlyResponse = getChatGptResponse(friendlyResultsPrompt)
            print(friendlyResponse)
        except Exception as err:
            error = str(err)
            print(err)

        questionResults.append({
            "question": question,
            "sql": sqlSyntaxResponse,
            "queryRawResponse": queryRawResponse,
            "friendlyResponse": friendlyResponse,
            "error": error
        })

    responses["questionResults"] = questionResults

    with open(f"response_{strategy}_{time()}.json", "w") as outFile:
        json.dump(responses, outFile, indent = 2)

fireEmblemCursor.close()
fireEmblemConn.close()